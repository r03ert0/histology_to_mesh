import json
import numpy as np
import os
import sys
import xmltodict as x2d
import re

# def json2array(data):
#     registered_contours = []
#     for ind in range(len(data)):
#         row = data[len(data) - ind -1]
#         new_row = []
#         for path in row:
#             new_path = np.array(path)
#             new_row.append(new_path)
#         registered_contours.append(new_row)
#     print(registered_contours[0][0].shape)

#     return registered_contours

def path_verts(p):
    d = p["@d"]
    verts = re.split(r"[MLZ]+", d)
    verts = verts[1:-1]
    verts = [[float(x) for x in row.split(",")] for row in verts]
    verts = np.array(verts)

    return verts

def apply_path_translation(p, dx, dy):
    verts = path_verts(p)
    new_verts = verts + [dx, dy]
    # new_verts = "M" + "L".join([ f"{x+dx},{y+dy}" for [x, y] in verts]) + "Z"

    return new_verts

def apply_path_transforms(p):
  if "@style" not in p or "transform" not in p["@style"]:
    return p

  style = p["@style"]
  tr = style.split("; transform:")[1]

  # apply translate transform
  xy = re.split(r"translate\(([^p]+)px,([^p]+)px\)/)", tr)
  if len(xy) != 2:
    return p

  [dx, dy] = [float(xy[1]), float(xy[2])]
  new_p = apply_path_translation(p, dx, dy)

  return new_p

def apply_group_transforms(g):
  '''apply group transforms to inner paths'''

  # print(g["@id"])
  # style = g["@style"]
  # transform = style.split("; transform:")[1]
  # tr = [re.split(r"([^\(]+)\(([^\)]+)\)", t)[1:3] for t in transform.split(" ") if len(t)>0]

  if "@style" not in g or "transform" not in g["@style"]:
      return g

  style = g["@style"]
  tr = style.split("; transform:")[1]

  # apply translate transforms
  x = re.split(r"translateX\(([^p]+)px\)", tr)
  y = re.split(r"translateY\(([^p]+)px\)", tr)
  [dx, dy] = [float(x[1]), float(y[1])]
  paths = g["path"]
  if not isinstance(paths, list):
    paths = [paths]
  
  new_g = []
  for p in paths:
    # apply path translation
    p_p = apply_path_transforms(p)

    # apply group translation
    p_g = apply_path_translation(p_p, dx, dy)

    new_g.append(p_g)

  return new_g


def apply_transforms(svg_dic):
  dic = []
  for slice in svg_dic["svg"]["g"]:
    new_slice = apply_group_transforms(slice)
    dic.append(new_slice)
  return dic

def convert_svg_contours(input, output):
  svg = None
  with open(input) as f:
    svg = f.read()
  svg_dic = x2d.parse(svg)

  registered_contours = apply_transforms(svg_dic)

  path = os.path.join(output)
  np.savez_compressed(
      path,
      allow_pickle=True,
      registered_contours=registered_contours)

def main(argv):

  if len(argv) != 3:
    print('''
    convert_svg_contours.py

    Usage:
      python convert_svg_contours.py input output

    Where:
      input: path to brain.json file generated by the register_contours UI.
      output: path to registered_contours.npz which can be used by the
        surface reconstruction pipeline. The surface reconstruction
        pipeline expects that file to be called "7_registered_contours.npz"
    ''')
    return

  _,input_file, output_file = argv

  convert_svg_contours(input_file, output_file)

if __name__ == "__main__":
  main(sys.argv)




  # print(g["@id"])
  # style = g["@style"]
  # transform = style.split("; transform:")[1]
  # tr = [re.split(r"([^\(]+)\(([^\)]+)\)", t)[1:3] for t in transform.split(" ") if len(t)>0]
  # # print(tr)
  # if isinstance(g["path"], list):
  #   print([p["@class"] for p in g["path"]])
  # else:
  #   print(g["path"]["@class"])

  # json
  # registered_contours = json2array(data)

  # path = os.path.join(output)
  # np.savez_compressed(
  #     path,
  #     allow_pickle=True,
  #     registered_contours=registered_contours)

def main(argv):

  if len(argv) != 3:
    print('''
    convert_svg_contours.py

    Usage:
      python convert_svg_contours.py input output

    Where:
      input: path to brain.json file generated by the register_contours UI.
      output: path to registered_contours.npz which can be used by the
        surface reconstruction pipeline. The surface reconstruction
        pipeline expects that file to be called "7_registered_contours.npz"
    ''')
    return

  _,input_file, output_file = argv

  convert_svg_contours(input_file, output_file)

if __name__ == "__main__":
    main(sys.argv)
